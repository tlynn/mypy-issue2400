-- TODO: The "N:"s should be "W:"s, but there are no other warnings?
-- TODO: Detect more literal constant conditions?  (Notably "if 0")
-- TODO: Merge implementation with normal type checking? (binder)
-- TODO: Check for NameErrors (unbound globals)?
-- TODO: Python 2 versions of list comprehension tests (problem in tests).
-- TODO: Python 2: Infer assignment when iterating over a non-empty literal?
-- TODO: Add tests that locals in if/elif/while conditions get checked.
-- TODO: Test using tuples around vars in for + comprehensions.
-- TODO: Test using tuples around vars in testUnboundLocalWithin....
-- TODO: Test "with".
-- TODO: Test "async with" and "async for". (PEP 492)

[case testUnboundLocalDel1]
def f():
    del x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalDel2]
def f(arg):
    x = 1
    del x
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalDel3]
def f():
    a, b, c, d = 'abcd'
    del ((b, c))
    a
    b  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment
    c  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment
    d
    del a
    del b  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment
    del c  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment
    del d

[builtins fixtures/tuple.pyi]

[case testUnboundLocalIfArg]
from typing import Any

def f(arg: Any):
    if arg:
        x = 1
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

-- FIXME: TODO: When "if 0" is constant
--[case testUnboundLocalIf0]
--def f():
--    if 0:
--        x = 1
--    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

-- FIXME: TODO: When "if 1" is constant
--[case testUnboundLocalIf1]
--def f():
--    if 1:
--        pass
--    else:
--        x = 1
--    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

-- FIXME: TODO: When "if 1" is constant
--[case testUnboundLocalIf1b]
--def f():
--    if 1:
--        a = b = 2
--    del b
--    a
--    b  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment

--[case testUnboundLocalIfSysExit]
--def f(arg):
--    if arg:
--        x = 1
--    else:
--        y = 1
--        sys.exit()
--    x
--    y  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment

--[case testUnboundLocalIfFalse]
--def f():
--    if False:
--        x = 1
--    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

--[case testUnboundLocalIfTrue]
--def f():
--    if True:
--        pass
--    else:
--        x = 1
--    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalListComprehension]
def f(arg):
    x = 1
    del x
    [1 for x in arg]
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension2]
def f(arg):
    x = 1
    del x
    [x for x in arg]
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension3]
x = 1

def f(arg):
    [x for x in arg]  # x is not a local in Py3
    return x

# This doesn't work in Py2 so we can't run test that this is detected.
[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension4]
def f(arg):
    x, y, z = 1, 2, 3
    del x, y, z
    [(x, other) for x, y in arg]
    [(y, other) for x, y in arg]
    [(z, other) for x, y in arg]  # N: May raise UnboundLocalError: local variable 'z' referenced before assignment
    return x, y  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension5]
def f():
    a, b, c = 1, 2, 3
    del a, b, c
    # Misuse b and c.
    [c for a in b for b in [1]]  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension6]
def f(arg):
    e, es = 1, 1
    del e, es
    [e for es in arg for e in es]

[builtins fixtures/list.pyi]

[case testUnboundLocalGeneratorExprPy3]
def f(arg):
    x = 1
    del x
    set(1 for x in arg)
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[builtins fixtures/set.pyi]

[case testUnboundLocalGeneratorExpr2Py3]
def f(arg):
    x = 1
    del x
    set(x for x in arg)
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[builtins fixtures/set.pyi]

[case testUnboundLocalGeneratorExpr3Py3]
def f(arg):
    x, y, z = 1, 2, 3
    del x, y, z
    set((x, other) for x, y in arg)
    set((y, other) for x, y in arg)
    # Py2: SyntaxError: can not delete variable 'z' referenced in nested scope
    set((z, other) for x, y in arg)  # N: May raise UnboundLocalError: local variable 'z' referenced before assignment
    return x, y  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment

[builtins fixtures/set.pyi]

[case testUnboundLocalGeneratorExpr4Py3]
def f(arg):
    a, b, c = 1, 2, 3
    del a, b, c
    # Misuse b and c.
    set(c for a in b for b in arg)  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment

[builtins fixtures/list.pyi]
[builtins fixtures/set.pyi]

[case testUnboundLocalGeneratorExpr5Py3]
def f(arg):
    e, es = 1, 1
    del e, es
    set(e for es in arg for e in es)

[builtins fixtures/set.pyi]

[case testUnboundLocalGeneratorExprPy2]
# flags: --py2
def f(arg):
    x = 1
    del x
    # FIXME: TODO: Using a loop because fixtures don't work with --py2
    for _ in (1 for x in arg): pass
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalGeneratorExpr2Py2]
# flags: --py2
def f(arg):
    x = 1
    del x
    # FIXME: TODO: Using a loop because fixtures don't work with --py2
    for _ in (x for x in arg): pass
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

# testUnboundLocalGeneratorExpr3 would be a syntax error in Python 2!

[case testUnboundLocalGeneratorExpr4Py2]
# flags: --py2
def f(arg):
    a, b, c = 1, 2, 3
    del a, b, c
    # Misuse b and c.
    # FIXME: TODO: Using a loop because fixtures don't work with --py2
    for _ in (c for a in b for b in arg): pass  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment

[case testUnboundLocalGeneratorExpr5Py2]
# flags: --py2
def f(arg):
    e, es = 1, 1
    del e, es
    # FIXME: TODO: Using a loop because fixtures don't work with --py2
    for _ in (e for es in arg for e in es): pass

[case testUnboundLocalWhile1]
def f(arg):
    while 1:
        z = 1
        if arg:
            break
    return z

[case testUnboundLocalWhileTrue]
def f(arg):
    while True:
        z = 1
        if arg:
            break
    return z

[case testUnboundLocalInferUnreachableIf]
def f(arg):
    if arg:
        x = 1
        raise BaseException()
    else:
        raise BaseException()
    x

[builtins fixtures/exception.pyi]

[case testUnboundLocalInferUnreachableTry]
def f(arg):
    try:
        1/arg
        x = 1
        raise BaseException()
    except:
        raise BaseException()
    x

[builtins fixtures/exception.pyi]

[case testUnboundLocalIfQuiteComplicated]
def f(arg, arg2):
    if arg:
        x, y = 1, 1
    elif arg2:
--        if 1:
--            x = 2
-- Replaced with next line
        x = 2
        y = 2
    else:
        y = 3
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    y

[case testUnboundLocalDelWithinIf]
def f(arg):
    e = 1
    if arg:
        del e
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalDelWithinElse]
def f(arg):
    e = 1
    if arg:
        pass
    else:
        del e
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalDelWithinElse2]
def f(arg):
    if arg:
        e = 1
    else:
        del e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalDelWithinElif]
def f(arg, arg2):
    e = 1
    if arg:
        pass
    elif arg2:
        del e
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalDelWithinElif2]
def f(arg, arg2):
    if arg:
        e = 1
    elif arg2:
        del e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalIfComplicated]
def f(arg, arg2, arg3, arg4):
    if arg:
        a = b = c = d = e = 1
    elif arg2:
        if 0:
            pass
        else:
            a = b = 2
        if 1:
            d = e = 2
        del e
    elif arg3:
        a = c = d = e = 3
    elif arg4:
        return
    else:
        a = d = e = 4
    a
    b  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment
    c  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment
    d
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalFor]
def f(arg):
    for x in arg:
        y = 1
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    y  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment

[case testUnboundLocalArgDelDel]
def f(arg):
    arg
    del arg
    del arg  # N: May raise UnboundLocalError: local variable 'arg' referenced before assignment

[case testUnboundLocalWith]
def f(arg):
    if arg:
        with open(os.devnull) as fh:
            fh
    fh  # N: May raise UnboundLocalError: local variable 'fh' referenced before assignment

[case testUnboundLocalNestedScopes]
def g():
    def f():
        x
        y  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment
        y = 1
    x = 1
    f()

[case testUnboundLocalTryRaise]
def f(arg):
    try:
        x = 1/arg
    except ZeroDivisionError as e:
        raise
    x

[case testUnboundLocalTryPython2a]
# flags: --py2
def f(arg):
    try:
        1/arg
    except ZeroDivisionError as e:
        pass
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalTryPython2b]
# flags: --py2
def f(arg):
    e = 1
    try:
        1/arg
    except ZeroDivisionError as e:
        pass
    e

[case testUnboundLocalTryPython2c]
# flags: --py2
def f(arg):
    try:
        e = 1
        x = 1
        1/arg
    except ZeroDivisionError as e:
        pass
    e
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

    # FIXME: Wrong: KeyboardInterrupt:
    # We would need to hoist the exception-proof "e = 1" to before the try
    # to avoid this, but the user can also do that.

[case testUnboundLocalTryPython2d]
# flags: --py2
def f():
    e = 'e'
    try:
        1/0
        x = 1
    except RuntimeError as e:
        x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    except ZeroDivisionError as e2:
        x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    e  # Ok in Python 2.
    e2  # N: May raise UnboundLocalError: local variable 'e2' referenced before assignment

[case testUnboundLocalTryPython3a]
def f(arg):
    try:
        1/arg
    except ZeroDivisionError as e:
        pass
        # Implicit "del e".
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalTryPython3b]
def f(arg):
    e = 1
    try:
        1/arg
    except ZeroDivisionError as e:
        pass
        # Implicit "del e".
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalTryPython3c]
def f(arg):
    try:
        e = 1
        x = 1
        1/arg
    except ZeroDivisionError as e:
        pass
        # Implicit "del e".
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalTryPython3d]
def f():
    e = 'e'
    try:
        1/0
        x = 1
    except RuntimeError as e:
        x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
        # Python 3 effectively inserts "del e" here.
    except ZeroDivisionError as e2:
        x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
        # Python 3 effectively inserts "del e2" here.
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment
    e2  # N: May raise UnboundLocalError: local variable 'e2' referenced before assignment

[case testUnboundLocalTryExceptions1]
def f(arg):
    try:
        if arg:
            raise BaseException()
    except:
        x = 1
    else:
        # TODO: Detect sys.exit()?
        raise BaseException()
    x

[builtins fixtures/exception.pyi]

[case testUnboundLocalTryExceptions2]
def f(arg):
    try:
        if arg:
            raise BaseException()
    except:
        x = 1
    else:
        pass
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[builtins fixtures/exception.pyi]

[case testUnboundLocalOpAssign]
def f():
    x += 1  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalFuncName]
def f():
    del f  # N: May raise UnboundLocalError: local variable 'f' referenced before assignment

[case testUnboundLocalInMethod]
class C(object):
    def method(self):
        x += 1  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment


#############################################################################
# Situations we could check for but don't (NameErrors from unbound globals).
# We still need the tests to make sure we don't confuse globals with locals.

[case testUnboundGlobal]
if 0:
    x = 1
x  # Top level is not currently checked for NameErrors.

[case testUnboundGlobalInFunc]
# It seems too hard to detect broken global dependencies usefully?
def f():
    return x

x = 1; f()  # Ok
del x; f()  # NameError not detected.

[case testUnboundGlobalInFunc2]
def f(arg1, arg2, arg3):
    if arg1: global x  # Affects whole function, even if arg1 is false.
    if arg2: x         # Ignored: We'd flag all reads from globals.
    if arg3: x += 1    # Ignored: No reason to treat writes differently.

[case testUnboundGlobalInFunc3]
# Use of a global after it has been explicitly deleted.
def f(arg1, arg2):
    global x
    if arg1:
        del x
    if arg2:
        return x  # Possible NameError not detected.
    del x
    return x  # NameError not detected.
