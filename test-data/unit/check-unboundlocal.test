-- TODO: The "N:"s should be "W:"s, but there are no other warnings?
-- TODO: Detect more literal constant conditions?  (Notably "if 0")
-- TODO: Merge implementation with normal type checking? (binder)
-- TODO: Check for NameErrors (unbound globals)?
-- TODO: Python 2 versions of list comprehension tests (problem in tests).
-- TODO: Python 2: Infer assignment when iterating over a non-empty literal?

[case testUnboundLocalJustDel]
def f():
    del x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalIfArg]
def f(arg):
    if arg:
        x = 1
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalIf0]
def f():
    if 0:
        x = 1
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalIf1]
def f():
    if 1:
        pass
    else:
        x = 1
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalIf1b]
def f():
    if 1:
        a = b = 2
    del b
    a
    b  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment

[case testUnboundLocalIfSysExit]
def f(arg):
    if arg:
        x = 1
    else:
        y = 1
        sys.exit()
    x
    y  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment

[case testUnboundLocalIfFalse]
def f():
    if False:
        x = 1
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalIfTrue]
def f():
    if True:
        pass
    else:
        x = 1
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalListComprehension]
def f(arg):
    x = 1
    del x
    [1 for x in arg]
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension2]
def f(arg):
    x = 1
    del x
    [x for x in arg]
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension3]
def f(arg):
    x, y, z = 1, 2, 3
    del x, y, z
    [(x, other) for x, y in arg]
    [(y, other) for x, y in arg]
    [(z, other) for x, y in arg]  # N: May raise UnboundLocalError: local variable 'z' referenced before assignment
    return x, y  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension4]
def f():
    a, b, c = 1, 2, 3
    del a, b, c
    # Misuse b but don't flag it in Python 3 since not a local
    [c for a in b for b in [1]]  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalListComprehension5]
def f(arg):
    e, es = 1, 1
    del e, es
    [e for es in arg for e in es]

[builtins fixtures/list.pyi]

[case testUnboundLocalGeneratorExpr]
def f(arg):
    x = 1
    del x
    set(1 for x in arg)
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalGeneratorExpr2]
def f(arg):
    x = 1
    del x
    set(x for x in arg)
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalGeneratorExpr3]
def f(arg):
    x, y, z = 1, 2, 3
    del x, y, z
    set((x, other) for x, y in arg)
    set((y, other) for x, y in arg)
    # Py2: SyntaxError: can not delete variable 'z' referenced in nested scope
    set((z, other) for x, y in arg)  # N: May raise UnboundLocalError: local variable 'z' referenced before assignment
    return x, y  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment

[case testUnboundLocalGeneratorExpr4]
def f(arg):
    a, b, c = 1, 2, 3
    del a, b, c
    # Misuse b but don't flag it in Python 3 since not a local
    set(c for a in b for b in arg)  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment

[builtins fixtures/list.pyi]

[case testUnboundLocalGeneratorExpr5]
def f(arg):
    e, es = 1, 1
    del e, es
    set(e for es in arg for e in es)


[case testUnboundLocalGeneratorExprPy2]
# flags: --py2
def f(arg):
    x = 1
    del x
    set(1 for x in arg)
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalGeneratorExpr2Py2]
# flags: --py2
def f(arg):
    x = 1
    del x
    set(x for x in arg)
    return x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

# testUnboundLocalGeneratorExpr3 would be a syntax error in Python 2!

[case testUnboundLocalGeneratorExpr4Py2]
# flags: --py2
def f(arg):
    a, b, c = 1, 2, 3
    del a, b, c
    # Misuse b but don't flag it in Python 3 since not a local
    set(c for a in b for b in arg)  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment

[case testUnboundLocalGeneratorExpr5Py2]
# flags: --py2
def f(arg):
    e, es = 1, 1
    del e, es
    set(e for es in arg for e in es)


[case testUnboundLocalWhile1]
def f(arg):
    while 1:
        z = 1
        if arg:
            break
    return z

[case testUnboundLocalWhileTrue]
def f(arg):
    while True:
        z = 1
        if arg:
            break
    return z

[case testUnboundLocalInferUnreachableIf]
def f(arg):
    if arg:
        x = 1
        raise BaseException()
    else:
        raise BaseException()
    x

[builtins fixtures/exception.pyi]

[case testUnboundLocalInferUnreachableTry]
def f(arg):
    try:
        1/arg
        x = 1
        raise BaseException()
    except:
        raise BaseException()
    x

[builtins fixtures/exception.pyi]

[case testUnboundLocalIfQuiteComplicated]
def f(arg, arg2):
    if arg:
        x, y = 1, 1
    elif arg2:
        if 1:
            x = 2
        y = 2
    else:
        y = 3
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    y

[case testUnboundLocalIfComplicated]
def f(arg, arg2, arg3, arg4):
    if arg:
        a = b = c = d = e = 1
    elif arg2:
        if 0:
            pass
        else:
            a = b = 2
        if 1:
            d = e = 2
        del e
    elif arg3:
        a = c = d = e = 3
    elif arg4:
        return
    else:
        a = d = e = 4
    a
    b  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment
    c  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment
    d
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalFor]
def f(arg):
    for x in range(arg):
        y = 1
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    y  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment

[case testUnboundLocalDel]
def f():
    a, b, c, d = 'abcd'
    del ((b, c))
    a
    b  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment
    c  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment
    d
    del a
    del b  # N: May raise UnboundLocalError: local variable 'b' referenced before assignment
    del c  # N: May raise UnboundLocalError: local variable 'c' referenced before assignment
    del d

[case testUnboundLocalArgDelDel]
def f(arg):
    arg
    del arg
    del arg  # N: May raise UnboundLocalError: local variable 'arg' referenced before assignment

[case testUnboundLocalWith]
def f(arg):
    if arg:
        with open(os.devnull) as fh:
            fh
    fh  # N: May raise UnboundLocalError: local variable 'fh' referenced before assignment

[case testUnboundLocalNestedScopes]
def g():
    def f():
        x
        y  # N: May raise UnboundLocalError: local variable 'y' referenced before assignment
        y = 1
    x = 1
    f()

[case testUnboundLocalTryRaise]
def f(arg):
    try:
        x = 1/arg
    except ZeroDivisionError as e:
        raise
    x

[case testUnboundLocalTryPython2a]
# flags: --py2
def f(arg):
    try:
        1/arg
    except ZeroDivisionError as e:
        pass
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalTryPython2b]
# flags: --py2
def f(arg):
    e = 1
    try:
        1/arg
    except ZeroDivisionError as e:
        pass
    e

[case testUnboundLocalTryPython2c]
# flags: --py2
def f(arg):
    try:
        e = 1
        x = 1
        1/arg
    except ZeroDivisionError as e:
        pass
    e
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

    # FIXME: Wrong: KeyboardInterrupt:
    # We would need to hoist the exception-proof "e = 1" to before the try
    # to avoid this, but the user can also do that.

[case testUnboundLocalTryPython2d]
# flags: --py2
def f():
    e = 'e'
    try:
        1/0
        x = 1
    except RuntimeError as e:
        x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    except ZeroDivisionError as e2:
        x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    e  # Ok in Python 2.
    e2  # N: May raise UnboundLocalError: local variable 'e2' referenced before assignment

[case testUnboundLocalTryPython3a]
def f(arg):
    try:
        1/arg
    except ZeroDivisionError as e:
        pass
        # Implicit "del e".
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalTryPython3b]
def f(arg):
    e = 1
    try:
        1/arg
    except ZeroDivisionError as e:
        pass
        # Implicit "del e".
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment

[case testUnboundLocalTryPython3c]
def f(arg):
    try:
        e = 1
        x = 1
        1/arg
    except ZeroDivisionError as e:
        pass
        # Implicit "del e".
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalTryPython3d]
def f():
    e = 'e'
    try:
        1/0
        x = 1
    except RuntimeError as e:
        x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
        # Python 3 effectively inserts "del e" here.
    except ZeroDivisionError as e2:
        x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
        # Python 3 effectively inserts "del e2" here.
    x  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment
    e  # N: May raise UnboundLocalError: local variable 'e' referenced before assignment
    e2  # N: May raise UnboundLocalError: local variable 'e2' referenced before assignment

[case testUnboundLocalTrySysExit]
def f(arg):
    try:
        if arg:
            raise BaseException()
    except:
        x = 1
    else:
        sys.exit()
    x

[builtins fixtures/exception.pyi]

[case testUnboundLocalOpAssign]
def f():
    x += 1  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment

[case testUnboundLocalFuncName]
def f():
    del f  # N: May raise UnboundLocalError: local variable 'f' referenced before assignment

[case testUnboundLocalInMethod]
class C(object):
    def method(self):
        x += 1  # N: May raise UnboundLocalError: local variable 'x' referenced before assignment


#############################################################################
# Situations we could check for but don't (NameErrors from unbound globals).
# We still need the tests to make sure we don't confuse globals with locals.

[case testUnboundGlobal]
if 0:
    x = 1
x  # Top level is not currently checked for NameErrors.

[case testUnboundGlobalInFunc]
# It seems too hard to detect broken global dependencies usefully?
def f():
    return x

x = 1; f()  # Ok
del x; f()  # NameError not detected.

[case testUnboundGlobalInFunc2]
def f(arg1, arg2, arg3):
    if arg1: global x  # Affects whole function, even if arg1 is false.
    if arg2: x         # Ignored: We'd flag all reads from globals.
    if arg3: x += 1    # Ignored: No reason to treat writes differently.

[case testUnboundGlobalInFunc3]
# Use of a global after it has been explicitly deleted.
def f(arg1, arg2):
    global x
    if arg1:
        del x
    if arg2:
        return x  # Possible NameError not detected.
    del x
    return x  # NameError not detected.
